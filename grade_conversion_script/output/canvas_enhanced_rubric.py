import enum
import pandas as pd
from pathlib import Path

from typing import * # pyright: ignore[reportWildcardImportFromLibrary]
import numbers as num
import pandera.pandas as pa
from pandera.typing import DataFrame

from .base import OutputFormat

from grade_conversion_script.util import NameSisIdConverter
from grade_conversion_script.util.types import SisId, PtsBy_StudentSisId
from grade_conversion_script.util.funcs import iter_by_element, is_pd_value_present
from grade_conversion_script.util.tui import interactive_rubric_criteria_match, interactive_name_sis_id_match

class CanvasEnhancedRubricOutputFormat(OutputFormat):
    '''
    Populate an Enhanced Rubric file generated by Canvas.

    Does not consider Rating label when determining
    whether an action would overwrite an existing grade.

    >>> name_sis_id = NameSisIdConverter()
    >>> name_sis_id.add(sis_id='name1', name='Name One')
    >>> rubric_csv = pd.DataFrame({
    ...                         'Student Name':           ["Name One",],
    ...                         'Criterion 1 - Rating':   ["Any Text",],
    ...                         'Criterion 1 - Points':   ["",        ],
    ...                         'Criterion 1 - Comments': ["",        ],
    ...                         'Criterion 2 - Rating':   ["",        ],
    ...                         'Criterion 2 - Points':   [5,         ],
    ...                         'Criterion 2 - Comments': ["excused", ],
    ...                     })
    >>> cerubric_output = CanvasEnhancedRubricOutputFormat(
    ...                         rubric_csv,
    ...                         name_sis_id,
    ...                         name_sis_id_match=lambda out, names_to_match, sis_ids_to_match: Exception(
    ...                                                 f"{out};{names_to_match};{sis_ids_to_match}"
    ...                                             ),
    ...                         rubric_criteria_match=( lambda given_labels, dest_labels: dict(zip(given_labels, dest_labels)) ),
    ...                         replace_existing=False,
    ...                         warn_existing=True
    ...                     )
    >>> grades = pd.DataFrame({
    ...                         'sis_id':      ['name1',],
    ...                         'Criterion 1': [3,      ],
    ...                         'Criterion 2': [4,      ]
    ...                     }).set_index('sis_id', drop=True)
    >>> new_csv = cerubric_output.format(grades)
    Keeping old grade of 5 at name1, Criterion 2 (Rating "" and Comment "excused")
    >>> new_csv[['Student Name', 'Criterion 1 - Points', 'Criterion 2 - Points']]
           Student Name Criterion 1 - Points  Criterion 2 - Points
    name1      Name One                    3                     5
    '''

    def __init__(
            self,
            rubric_csv: pd.DataFrame,
            name_sis_id_converter: NameSisIdConverter,
            replace_existing: bool,
            warn_existing: bool,
            name_sis_id_match=interactive_name_sis_id_match,
            rubric_criteria_match=interactive_rubric_criteria_match
        ):
        super().__init__()
        
        self.name_sis_id_converter = name_sis_id_converter
            # note: may not be populated at __init__() call time
        
        self.rubric_template = rubric_csv
        
        self.replace_existing = replace_existing
        self.warn_existing = warn_existing

        self.name_sis_id_match = name_sis_id_match
        self.rubric_criteria_match = rubric_criteria_match

    @override
    @pa.check_types
    def format(self, grades: DataFrame[PtsBy_StudentSisId]) -> pd.DataFrame:
        '''
        Args:
            grades:
                One column per rubric criteria.
                One row per student.
        Returns:
            A dataframe which can be saved to file with self.write_file().
        '''

        # Translate rubric + input: sis_ids -> names

        all_dest_names = self.rubric_template['Student Name'].astype(str).to_list()
        all_input_names = self.name_sis_id_converter.names

        unrecognized_dest_names = set(all_dest_names) - set(all_input_names)
        unused_input_names = set(all_input_names) - set(all_dest_names)
        unused_input_sis_ids = [self.name_sis_id_converter.to_sis_id(x) for x in unused_input_names]

        for sis_id in unused_input_sis_ids:
            self.name_sis_id_converter.remove_sis_id(sis_id)
        self.name_sis_id_match(
            names_to_match=unrecognized_dest_names,
            sis_ids_to_match=unused_input_sis_ids,
            out=self.name_sis_id_converter
        )

        # In order to reindex rubric by sis_id,
        # each name therein needs a corresponding entry
        # in `name_sis_id_converter`.
        #
        # However, not everyone from rubric is in input `grades` at all.
        # This means we have no source to get their sis_id from anyways.
        #
        # TODO Instead, implement a default_grade option (None | num.Real)
        all_input_names = self.name_sis_id_converter.names # this value has changed
        still_unrecognized_dest_names = set(all_dest_names) - set(all_input_names)
        is_recognized_row_mask = ~(self.rubric_template['Student Name']
                                   .isin(still_unrecognized_dest_names))        

        rubric_by_sis_id = pd.concat([
            self.name_sis_id_converter.reindex_by_sis_id(
                self.rubric_template[is_recognized_row_mask],
                'Student Name'
            ),
            self.rubric_template[~is_recognized_row_mask]
        ])

        # Translate input: column label -> rubric criterion

        user_criteria = grades.columns.to_list()
        canvas_criteria = self.rubric_template.columns.to_list()
            # ^ start with all rubric columns
        canvas_criteria = filter(lambda x: x.endswith(" - Points"), canvas_criteria)
            # ^ pull one column label for each criteria
        canvas_criteria = (x[:-1 * len(" - Points")] for x in canvas_criteria)
            # ^ cut off " - Points" suffix

        given_to_dest_criteria = self.rubric_criteria_match(
            given_labels=user_criteria,
            dest_labels=canvas_criteria
        )
        
        grades.columns = grades.columns.map(given_to_dest_criteria)
        
        # Keep around intermediate copy for assert at the end
        new_rubric = rubric_by_sis_id.copy()
        
        # Iterate by `grades` dataframe
        grades_iter = cast(
            Iterable[
                tuple[SisId, str, num.Real]
            ],
            iter_by_element(grades)
        )

        # if a student was ignored by user, do not iterate over it.
        # otherwise, we end up searching for it in the rubric, and it
        # might not exist.
        grades_iter = filter(
            lambda loc_in_grades:
                loc_in_grades.row in self.name_sis_id_converter.sis_ids,
            grades_iter
        )

        for student, criterion, param_score in grades_iter:
            # Get corresponding columns in Canvas enhanced rubric CSV
            SemanticLabel = enum.Enum('SemanticLabel', ['PTS_LABEL', 'PTS', 'COMMENTS'])
            criterion_csv_headers: dict[SemanticLabel, str] = \
            {
                semantic_label: criterion + suffix
                for semantic_label, suffix in {
                                        # These go after the criterion name
                                        SemanticLabel.PTS_LABEL: " - Rating",
                                        SemanticLabel.PTS      : " - Points",
                                        SemanticLabel.COMMENTS : " - Comments"
                                    }.items()
            }
            def get_gradebook_curr(semantic_label: SemanticLabel) -> num.Real | str:
                col_header = criterion_csv_headers[semantic_label]
                value = new_rubric.at[student, col_header]
                assert isinstance(value, (num.Real, str))
                return value
            def set_gradebook_curr(semantic_label: SemanticLabel, value: num.Real | str):
                col_header = criterion_csv_headers[semantic_label]
                cast_value = cast(float | int, value) # pyright doesn't know Real is a scalar
                new_rubric.at[student, col_header] = cast_value
            
            # Should we fill the current criterion for the current student?
            grade_already_present: bool = \
                any(
                    is_pd_value_present( get_gradebook_curr(semantic_label) )
                    for semantic_label in (SemanticLabel.PTS, SemanticLabel.COMMENTS)
                )
            should_fill_curr = (not grade_already_present) or self.replace_existing

            # Print warning if requested
            should_warn_curr = self.warn_existing and grade_already_present
            if should_warn_curr:
                match should_fill_curr:
                    case True:
                        message = (
                            f'Replacing old grade of {get_gradebook_curr(SemanticLabel.PTS)}'
                            f' with new grade {param_score} at {student},'
                            f' {criterion} (keeping Rating of "{get_gradebook_curr(SemanticLabel.PTS_LABEL)}"'
                            f' and Comment of "{get_gradebook_curr(SemanticLabel.COMMENTS)}")'
                        )
                    case False:
                        message = (
                            f'Keeping old grade of {get_gradebook_curr(SemanticLabel.PTS)}'
                            f' at {student}, {criterion} (Rating'
                            f' "{get_gradebook_curr(SemanticLabel.PTS_LABEL)}"'
                            f' and Comment "{get_gradebook_curr(SemanticLabel.COMMENTS)}")'
                        )
                print(message)

            # Fill score for curr criterion & student
            if should_fill_curr:
                set_gradebook_curr(SemanticLabel.PTS, param_score)
        
        # We only touched "Points" columns that were specified in the input
        modified_columns: list[str] = [f"{criterion} - Points"
                                       for criterion in grades.columns]
        assert (
            rubric_by_sis_id
                .drop(modified_columns, axis='columns', inplace=False)
        ).equals(
            new_rubric
                .drop(modified_columns, axis='columns', inplace=False)
        )

        return new_rubric
    
    @override
    @classmethod
    def write_file(cls, self_output: pd.DataFrame, filepath: Path) -> None:
        self_output.to_csv(filepath, index=False, header=True)